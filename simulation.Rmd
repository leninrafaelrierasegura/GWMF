---
title: "Simulation"
date: "Created: 05-07-2024. Last modified: `r format(Sys.time(), '%d-%m-%Y.')`"
output:
  html_document:
    mathjax: "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    highlight: pygments
    theme: flatly
    code_folding: show # class.source = "fold-hide" to hide code and add a button to show it
    # df_print: paged
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
    number_sections: true
    fig_caption: true
always_allow_html: true
bibliography: 
  - references.bib
  - grateful-refs.bib
header-includes:
  - \newcommand{\ar}{\mathbb{R}}
  - \newcommand{\llav}[1]{\left\{#1\right\}}
  - \newcommand{\pare}[1]{\left(#1\right)}
  - \newcommand{\Ncal}{\mathcal{N}}
  - \newcommand{\Vcal}{\mathcal{V}}
  - \newcommand{\Ecal}{\mathcal{E}}
---

```{r, eval = FALSE, echo = FALSE}
################################################################################
################################################################################
################################################################################
################################################################################
######### DO NOT FORGET TO CHANGE THE TITLE EVERY TIME YOU FIT A MODEL #########
################################################################################
################################################################################
################################################################################
################################################################################
```

```{r xaringanExtra-clipboard, echo = FALSE}
htmltools::tagList(
  xaringanExtra::use_clipboard(
    button_text = "<i class=\"fa-solid fa-clipboard\" style=\"color: #00008B\"></i>",
    success_text = "<i class=\"fa fa-check\" style=\"color: #90BE6D\"></i>",
    error_text = "<i class=\"fa fa-times-circle\" style=\"color: #F94144\"></i>"
  ),
  rmarkdown::html_dependency_font_awesome()
)
```


```{css, echo = FALSE}
body .main-container {
  max-width: 100% !important;
  width: 100% !important;
}
body {
  max-width: 100% !important;
}

body, td {
   font-size: 16px;
}
code.r{
  font-size: 14px;
}
pre {
  font-size: 14px
}
```


Go back to the [About page](about.html).

Let us set some global options for all code chunks in this document.


```{r}
knitr::opts_chunk$set(
  message = FALSE,    # Disable messages printed by R code chunks
  warning = FALSE,    # Disable warnings printed by R code chunks
  echo = TRUE,        # Show R code within code chunks in output
  include = TRUE,     # Include both R code and its results in output
  eval = TRUE,       # Evaluate R code chunks
  cache = FALSE,       # Enable caching of R code chunks for faster rendering
  fig.align = "center",
  out.width = "100%",
  retina = 2,
  error = TRUE,
  collapse = FALSE
)
rm(list = ls())
set.seed(1982)
```

# Import libraries

```{r}
library(INLA)
library(inlabru)
library(rSPDE)
library(MetricGraph)

library(dplyr)
library(plotly)

library(here)
library(rmarkdown)
library(grateful) # Cite all loaded packages

rm(list = ls()) # Clear the workspace
set.seed(1982) # Set seed for reproducibility
```

# Build the graph

```
{r, fig.height = 6}
edges <- logo_lines() # This is a function from MetricGraph package that returns a list of edges
logo_graph <- metric_graph$new(edges = edges) # Create a new graph object

#logo_graph$prune_vertices()
logo_graph$build_mesh(h = 0.05) # Build the mesh

sigma <- 0.1 
range <- 10 
nu <- 1.5 # Smoothness parameter

# Construct the approximation
op <- matern.operators(nu = nu, 
                       sigma = sigma,
                       range = range,  
                       parameterization = "matern",
                       graph = logo_graph)    

# Simulate the field
cov <- as.vector(simulate(op))

# Non-stationary parameters
B.sigma = cbind(0, 1, 0, cov, 0)
B.range = cbind(0, 0, 1, 0, cov)

# Log-regression coefficients
theta = c(1,1,-2.5,2.5)

nu <- 0.75
# Construct the approximation 
ns_op <- rSPDE::spde.matern.operators(graph = logo_graph,
                                                parameterization = "matern",
                                                B.sigma = B.sigma,
                                                B.range = B.range,
                                                theta = theta,
                                                nu = nu)

# Covariance matrix
est_cov_matrix <- ns_op$covariance_mesh()

# Precision matrix
Q <- precision(ns_op)
```



```
{r}
u_non_stat <- simulate(ns_op)
```


```
{r}
obs.per.edge <- 100
obs.loc <- NULL
for(i in 1:logo_graph$nE) {
  obs.loc <- rbind(obs.loc,
                   cbind(rep(i,obs.per.edge), runif(obs.per.edge)))
}
n.obs <- obs.per.edge*logo_graph$nE
A <- logo_graph$fem_basis(obs.loc)
```


```
{r}
sigma.e <- 0.1

x1 <- obs.loc[,1]
x2 <- obs.loc[,2]

Y <- 1 + 2*x1 - 3*x2 + as.vector(A %*% u_non_stat + sigma.e * rnorm(n.obs))

df_data <- data.frame(y = Y, edge_number = obs.loc[,1],
                        distance_on_edge = obs.loc[,2],
                        x1 = x1, x2 = x2)

logo_graph$add_observations(data = df_data, normalized = TRUE)
```
```
{r}
data <- logo_graph$get_data()
aux <- data |>
  rename(distance_on_edge = .distance_on_edge, edge_number = .edge_number) |> # Rename the variables (because sf_graph$compute_geodist_PtE() requires so)
  as.data.frame() |> # Transform to a data frame (i.e., remove the metric_graph class)
  dplyr::select(edge_number, distance_on_edge)

# aux <- df_data |> dplyr::select(edge_number, distance_on_edge)

# Compute the distance matrix
distmatrix <- logo_graph$compute_geodist_PtE(PtE = aux,
                                             normalized = TRUE,
                                             include_vertices = FALSE)
```

```
{r}
# Define the distance vector
distance = seq(from = 0, to = 20, by = 2)

GROUPS <- list()
for (j in 1:length(distance)) {
  GROUPS[[j]] = list()
  for (i in 1:nrow(aux)) {
    GROUPS[[j]][[i]] <- which(as.vector(distmatrix[i, ]) <= distance[j])
     
  }
}
```

```
{r}
rspde_model_stat <- rspde.metric_graph(logo_graph,
                                       parameterization = "matern",
                                       nu = nu)

data_rspde_bru_stat <- graph_data_rspde(rspde_model_stat,
                                        loc_name = "loc")
cmp_stat <- y ~ -1 +
  Intercept(1) +
  x1 +
  x2 +
  field(loc, model = rspde_model_stat)

rspde_fit_stat <-
  bru(cmp_stat,
      data = data_rspde_bru_stat[["data"]],
      family = "gaussian",
      options = list(verbose = FALSE)
  )
```


```
{r}
rspde_model_nonstat <- rspde.metric_graph(logo_graph,
                                          B.sigma = B.sigma,
                                          B.range = B.range,
                                          parameterization = "matern",
                                          nu = nu)

data_rspde_bru_nonstat <- graph_data_rspde(rspde_model_nonstat,
                                           loc_name = "loc")
cmp_nonstat <- y ~ -1 +
  Intercept(1) +
  x1 +
  x2 +
  field(loc, model = rspde_model_nonstat)

rspde_fit_nonstat <-
  bru(cmp_nonstat,
      data = data_rspde_bru_nonstat[["data"]],
      family = "gaussian",
      options = list(verbose = FALSE)
  )
```

```
{r}
mse.stat <- mse.nonstat <- ls.stat <- ls.nonstat <- rep(0,length(distance))
# cross-validation for-loop
for (j in 1:length(distance)) {
  print(j)
  # cross-validation of the stationary model
  cv.stat <- inla.group.cv(rspde_fit_stat, groups = GROUPS[[j]])
  # cross-validation of the nonstationary model
  cv.nonstat <- inla.group.cv(rspde_fit_nonstat, groups = GROUPS[[j]])
  # obtain MSE and LS
  mse.stat[j] <- mean((cv.stat$mean - data$y)^2)
  mse.nonstat[j] <- mean((cv.nonstat$mean - data$y)^2)
  ls.stat[j] <- mean(log(cv.stat$cv))
  ls.nonstat[j] <- mean(log(cv.nonstat$cv))
}
```

# References

```{r}
cite_packages(output = "paragraph", out.dir = ".")
```
