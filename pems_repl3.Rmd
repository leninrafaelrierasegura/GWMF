---
title: "PeMS 3, covariance features"
date: "Created: 05-07-2024. Last modified: `r format(Sys.time(), '%d-%m-%Y.')`"
output:
  html_document:
    mathjax: "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    highlight: pygments
    theme: flatly
    code_folding: show # class.source = "fold-hide" to hide code and add a button to show it
    df_print: paged
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
    number_sections: false
    fig_caption: true
    code_download: true
always_allow_html: true
bibliography: 
  - references.bib
  - grateful-refs.bib
header-includes:
  - \newcommand{\ar}{\mathbb{R}}
  - \newcommand{\llav}[1]{\left\{#1\right\}}
  - \newcommand{\pare}[1]{\left(#1\right)}
  - \newcommand{\Ncal}{\mathcal{N}}
  - \newcommand{\Vcal}{\mathcal{V}}
  - \newcommand{\Ecal}{\mathcal{E}}
  - \newcommand{\Wcal}{\mathcal{W}}
---

```{r xaringanExtra-clipboard, echo = FALSE}
htmltools::tagList(
  xaringanExtra::use_clipboard(
    button_text = "<i class=\"fa-solid fa-clipboard\" style=\"color: #00008B\"></i>",
    success_text = "<i class=\"fa fa-check\" style=\"color: #90BE6D\"></i>",
    error_text = "<i class=\"fa fa-times-circle\" style=\"color: #F94144\"></i>"
  ),
  rmarkdown::html_dependency_font_awesome()
)
```


```{css, echo = FALSE}
body .main-container {
  max-width: 100% !important;
  width: 100% !important;
}
body {
  max-width: 100% !important;
}

body, td {
   font-size: 16px;
}
code.r{
  font-size: 14px;
}
pre {
  font-size: 14px
}
.custom-box {
  background-color: #f5f7fa; /* Light grey-blue background */
  border-color: #e1e8ed; /* Light border color */
  color: #2c3e50; /* Dark text color */
  padding: 15px; /* Padding inside the box */
  border-radius: 5px; /* Rounded corners */
  margin-bottom: 20px; /* Spacing below the box */
}
.caption {
  margin: auto;
  text-align: center;
  margin-bottom: 20px; /* Spacing below the box */
}
```


Go back to the [About page](about.html). 


This vignette uses the parameters stored in [**`pems_repl2_results.RData`**](https://github.com/leninrafaelrierasegura/GWMF/blob/main/data_files/pems_repl2_results.RData), which was created in [pems_repl2.html](pems_repl2.html), to compute some covariance features.

Let us set some global options for all code chunks in this document.


```{r}
# Set seed for reproducibility
set.seed(1982) 
# Set global options for all code chunks
knitr::opts_chunk$set(
  # Disable messages printed by R code chunks
  message = FALSE,    
  # Disable warnings printed by R code chunks
  warning = FALSE,    
  # Show R code within code chunks in output
  echo = TRUE,        
  # Include both R code and its results in output
  include = TRUE,     
  # Evaluate R code chunks
  eval = TRUE,       
  # Enable caching of R code chunks for faster rendering
  cache = FALSE,      
  # Align figures in the center of the output
  fig.align = "center",
  # Enable retina display for high-resolution figures
  retina = 2,
  # Show errors in the output instead of stopping rendering
  error = TRUE,
  # Do not collapse code and output into a single block
  collapse = FALSE
)
```

Below we load the necessary libraries.

```{r}
library(INLA)
library(inlabru)
library(rSPDE)
library(MetricGraph)

library(dplyr)
library(plotly)
library(scales)
library(patchwork)

library(ggplot2)
library(cowplot)
library(ggpubr) #annotate_figure()
library(grid) #textGrob()
library(ggmap)

library(viridis)
library(OpenStreetMap)


library(tidyr)
library(sf)

library(here)
library(rmarkdown)
library(grateful) # Cite all loaded packages
```


Below we define the function `captioner()` to generate captions for the figures and the function `process_model_results()` to extract the summary of the parameters of the model.

Below we also define function `compute_pcr()`, which computes the practical correlation. It receives the output of the [`rSPDE::spde.matern.operators()`](https://davidbolin.github.io/rSPDE/reference/spde.matern.operators.html) function (when evaluated on compatible parameters) and a threshold `cor_threshold`. Using the correlation matrix and the geodesic distance matrix, for each point in the mesh, it computes the practical correlation range as the minimum geodesic distance such that the correlation is below a given threshold `cor_threshold` (usually defined as 0.1). The function returns a vector with the practical correlation range for each point in the mesh.

<div style="color: blue;">
********
**Press the Show button below to reveal the code.**

********
</div>

```{r, class.source = "fold-hide"}
# Start the figure counter
fig_count <- 0
# Define the captioner function
captioner <- function(caption) {
  fig_count <<- fig_count + 1
  paste0("Figure ", fig_count, ": ", caption)
}
process_model_results <- function(fit, model) {
  fit_spde <- rspde.result(fit, "field", model, parameterization = "spde")
  fit_matern <- rspde.result(fit, "field", model, parameterization = "matern")
  df_for_plot_spde <- gg_df(fit_spde)
  df_for_plot_matern <- gg_df(fit_matern)
  param_spde <- summary(fit_spde)
  param_matern <- summary(fit_matern)
  param_fixed <- fit$summary.fixed[,1:6]
  marginal.posterior.sigma_e = inla.tmarginal(
    fun = function(x) exp(-x/2), 
    marginal = fit[["internal.marginals.hyperpar"]][["Log precision for the Gaussian observations"]])
  quant.sigma_e <- capture.output({result_tmp <- inla.zmarginal(marginal.posterior.sigma_e)}, file = "/dev/null") 
  quant.sigma_e <- result_tmp
  statistics.sigma_e <- unlist(quant.sigma_e)[c(1,2,3,5,7)]
  mode.sigma_e <- inla.mmarginal(marginal.posterior.sigma_e)
  allparams <- rbind(param_fixed, param_spde, param_matern, c(statistics.sigma_e, mode.sigma_e))
  rownames(allparams)[nrow(allparams)] <- "sigma_e"
  return(list(allparams = allparams, df_for_plot_spde = df_for_plot_spde, df_for_plot_matern = df_for_plot_matern))
}
compute_pcr <- function(op, cor_threshold) {
  # Compute the covariance matrix
  cov_matrix <- op$covariance_mesh() 
  # Compute the correlation matrix
  cor_matrix <-cov2cor(cov_matrix)
  # Compute the geodesic distance matrix
  op$graph$compute_geodist_mesh() 
  # Extract the geodesic distance matrix
  dist_matrix <- op$graph$mesh$geo_dist 
  # Initialize the vector to store the practical correlation range
  pcr <- numeric(dim(cor_matrix)[1]) 
  
  process_row <- function(row_index) {
    # For each row_index, create an auxiliary matrix aux_mat with the correlation and geodesic distance
    aux_mat <- cbind(cor_matrix[row_index, ], dist_matrix[row_index, ]) 
    # Order the auxiliary matrix by the geodesic distance
    ordered_aux_mat <- aux_mat[order(aux_mat[, 2]), ] 
    # Filter the auxiliary ordered matrix by the correlation threshold
    filtered_aux_mat <- ordered_aux_mat[ordered_aux_mat[,1] < cor_threshold, ] 
    if (nrow(filtered_aux_mat) > 0) {
      # Return the minimum geodesic distance such that the correlation is below the threshold
      return(filtered_aux_mat[1, 2]) 
    } else {
      # If the condition is not satisfied, record the minimum correlation value and return an error message
      min <- min(aux_mat[, 1])
      stop(paste0("The condition cor_matrix[row_index, ] < cor_threshold is not satisfied for row_index = ", 
                  row_index, ". Increase cor_threshold. The minimum value of cor_matrix[row_index, ] is ",
                  min))
    }
  }
  
  pcr <- sapply(1:dim(cor_matrix)[1], process_row)
  
  return(pcr)
}
```

We first load `pems_repl2_results.RData` (which contains a list `list_to_save`) and extract its content.

```{r}
# Load the data
load(here("data_files/pems_repl2_results.RData"))
# Extract its content
graph <- list_to_save$graph
B.tau <- list_to_save$B.tau
B.kappa <- list_to_save$B.kappa
# Each of the objects below is a matrix with two columns, the first column is the mean and the second column is the mode
# Refer to pems_repl2.html for more details about their content
mean_and_mode_params_statnu0.5 <- list_to_save$mean_and_mode_params_statnu0.5
mean_and_mode_params_nonstatnu0.5 <- list_to_save$mean_and_mode_params_nonstatnu0.5
mean_and_mode_params_statnu1.5 <- list_to_save$mean_and_mode_params_statnu1.5
mean_and_mode_params_nonstatnu1.5 <- list_to_save$mean_and_mode_params_nonstatnu1.5
mean_and_mode_params_statnuest <- list_to_save$mean_and_mode_params_statnuest
mean_and_mode_params_nonstatnuest <- list_to_save$mean_and_mode_params_nonstatnuest
```


Below we define the correlation threshold to compute the practical correlation range.


```{r}
# Define correlation threshold
cor_threshold <- 0.7 
```


# Case $\nu = 0.5$

Below we consider the parameters obtained for the stationary model with $\nu = 0.5$.

```{r}
tau_statnu0.5 <- mean_and_mode_params_statnu0.5[3,1]
kappa_statnu0.5 <- mean_and_mode_params_statnu0.5[4,1]
op_statnu0.5 <- rSPDE::matern.operators(graph = graph,
                                            parameterization = "spde",
                                            tau = tau_statnu0.5,
                                            kappa = kappa_statnu0.5,
                                            alpha = 1)


# Precision matrix
Q_statnu0.5 <- precision(op_statnu0.5)
est_sigma_statnu0.5 <- sqrt(diag(INLA::inla.qinv(Q_statnu0.5))) 
est_range_statnu0.5 <- compute_pcr(op_statnu0.5, cor_threshold)
```


```{r, fig.width = 9.22, fig.height = 4.01, fig.cap = captioner("Standard deviation and practical correlation range for the stationary model with $\\nu = 0.5$.")}
# Create a plot of the standard deviation
s <- graph$plot_function(X = est_sigma_statnu0.5, vertex_size = 0, plotly = FALSE) +
  ggtitle("Standard deviation") +
  theme_minimal() +
  theme(text = element_text(family = "Palatino"))
# Create a plot of the practical correlation range
r <- graph$plot_function(X = est_range_statnu0.5, vertex_size = 0, plotly = FALSE) +
  ggtitle("Practical correlation range") +
  theme_minimal() +
  theme(text = element_text(family = "Palatino"))
sr <- s + r
print(sr)
```

Below we consider the parameters obtained for the non-stationary model with $\nu = 0.5$.

```{r}
theta_nonstatnu0.5 <- mean_and_mode_params_nonstatnu0.5[3:6,1]
op_nonstatnu0.5 <- rSPDE::spde.matern.operators(graph = graph,
                                            parameterization = "spde",
                                            B.tau = B.tau,
                                            B.kappa = B.kappa,
                                            theta = theta_nonstatnu0.5,
                                            alpha = 1)


# Precision matrix
Q_nonstatnu0.5 <- precision(op_nonstatnu0.5)
est_sigma_nonstatnu0.5 <- sqrt(diag(INLA::inla.qinv(Q_nonstatnu0.5))) 
est_range_nonstatnu0.5 <- compute_pcr(op_nonstatnu0.5, cor_threshold)

est_tau_nonstatnu0.5 <- exp(B.tau[,-1]%*%theta_nonstatnu0.5)
est_kappa_nonstatnu0.5 <- exp(B.kappa[,-1]%*%theta_nonstatnu0.5)
```

```{r, fig.width = 9.22, fig.height = 7.05, fig.cap = captioner("Standard deviation, practical correlation range, the model for tau, and the model for kappa for the non-stationary model with $\\nu = 0.5$.")}
# Create a plot of the standard deviation
s <- graph$plot_function(X = est_sigma_nonstatnu0.5, vertex_size = 0, plotly = FALSE) +
  ggtitle("Standard deviation") +
  theme_minimal() +
  theme(text = element_text(family = "Palatino"))
# Create a plot of the practical correlation range
r <- graph$plot_function(X = est_range_nonstatnu0.5, vertex_size = 0, plotly = FALSE) +
  ggtitle("Practical correlation range") +
  theme_minimal() +
  theme(text = element_text(family = "Palatino"))
u <- graph$plot_function(X = est_tau_nonstatnu0.5, vertex_size = 0, plotly = FALSE) +
  ggtitle("Model for tau") +
  theme_minimal() +
  theme(text = element_text(family = "Palatino"))
# Create a plot of the practical correlation range
k <- graph$plot_function(X = est_kappa_nonstatnu0.5, vertex_size = 0, plotly = FALSE) +
  ggtitle("Model for kappa") +
  theme_minimal() +
  theme(text = element_text(family = "Palatino"))
sruk <- (s + r) / (u + k)
print(sruk)
```

# Case $\nu = 1.5$

Below we consider the parameters obtained for the stationary model with $\nu = 1.5$.

```{r}
tau_statnu1.5 <- mean_and_mode_params_statnu1.5[3,1]
kappa_statnu1.5 <- mean_and_mode_params_statnu1.5[4,1]
op_statnu1.5 <- rSPDE::matern.operators(graph = graph,
                                        parameterization = "spde",
                                        tau = tau_statnu1.5,
                                        kappa = kappa_statnu1.5,
                                        alpha = 2)


# Precision matrix
Q_statnu1.5 <- precision(op_statnu1.5)
est_sigma_statnu1.5 <- sqrt(diag(INLA::inla.qinv(Q_statnu1.5))) 
est_range_statnu1.5 <- compute_pcr(op_statnu1.5, cor_threshold)
```


```{r, fig.width = 9.22, fig.height = 4.01, fig.cap = captioner("Standard deviation and practical correlation range for the stationary model with $\\nu = 1.5$.")}
# Create a plot of the standard deviation
s <- graph$plot_function(X = est_sigma_statnu1.5, vertex_size = 0, plotly = FALSE) +
  ggtitle("Standard deviation") +
  theme_minimal() +
  theme(text = element_text(family = "Palatino"))
# Create a plot of the practical correlation range
r <- graph$plot_function(X = est_range_statnu1.5, vertex_size = 0, plotly = FALSE) +
  ggtitle("Practical correlation range") +
  theme_minimal() +
  theme(text = element_text(family = "Palatino"))
sr <- s + r
print(sr)
```

Below we consider the parameters obtained for the non-stationary model with $\nu = 1.5$.

```{r}
theta_nonstatnu1.5 <- mean_and_mode_params_nonstatnu1.5[3:6,1]
op_nonstatnu1.5 <- rSPDE::spde.matern.operators(graph = graph,
                                                parameterization = "spde",
                                                B.tau = B.tau,
                                                B.kappa = B.kappa,
                                                theta = theta_nonstatnu1.5,
                                                alpha = 2)


# Precision matrix
Q_nonstatnu1.5 <- precision(op_nonstatnu1.5)
est_sigma_nonstatnu1.5 <- sqrt(diag(INLA::inla.qinv(Q_nonstatnu1.5))) 
est_range_nonstatnu1.5 <- compute_pcr(op_nonstatnu1.5, cor_threshold)

est_tau_nonstatnu1.5 <- exp(B.tau[,-1]%*%theta_nonstatnu1.5)
est_kappa_nonstatnu1.5 <- exp(B.kappa[,-1]%*%theta_nonstatnu1.5)
```


```{r, fig.width = 9.22, fig.height = 7.05, fig.cap = captioner("Standard deviation, practical correlation range, the model for tau, and the model for kappa for the non-stationary model with $\\nu = 1.5$.")}
# Create a plot of the standard deviation
s <- graph$plot_function(X = est_sigma_nonstatnu1.5, vertex_size = 0, plotly = FALSE) +
  ggtitle("Standard deviation") +
  theme_minimal() +
  theme(text = element_text(family = "Palatino"))
# Create a plot of the practical correlation range
r <- graph$plot_function(X = est_range_nonstatnu1.5, vertex_size = 0, plotly = FALSE) +
  ggtitle("Practical correlation range") +
  theme_minimal() +
  theme(text = element_text(family = "Palatino"))
u <- graph$plot_function(X = est_tau_nonstatnu1.5, vertex_size = 0, plotly = FALSE) +
  ggtitle("Model for tau") +
  theme_minimal() +
  theme(text = element_text(family = "Palatino"))
# Create a plot of the practical correlation range
k <- graph$plot_function(X = est_kappa_nonstatnu1.5, vertex_size = 0, plotly = FALSE) +
  ggtitle("Model for kappa") +
  theme_minimal() +
  theme(text = element_text(family = "Palatino"))
sruk <- (s + r) / (u + k)
print(sruk)
```

# Case $\nu$ estimated

Below we consider the parameters obtained for the stationary model with $\nu$ estimated.

```{r}
tau_statnuest <- mean_and_mode_params_statnuest[3,1]
kappa_statnuest <- mean_and_mode_params_statnuest[4,1]
nu_statnuest <- mean_and_mode_params_statnuest[5,1]
op_statnuest <- rSPDE::matern.operators(graph = graph,
                                        parameterization = "spde",
                                        tau = tau_statnuest,
                                        kappa = kappa_statnuest,
                                        alpha = 0.5 + nu_statnuest)


# Precision matrix
Q_statnuest <- precision(op_statnuest)
est_sigma_statnuest <- sqrt(diag(INLA::inla.qinv(Q_statnuest))) 
est_range_statnuest <- compute_pcr(op_statnuest, cor_threshold)
```


```{r, fig.width = 9.22, fig.height = 4.01, fig.cap = captioner("Standard deviation and practical correlation range for the stationary model with $\\nu$ estimated.")}
# Create a plot of the standard deviation
s <- graph$plot_function(X = est_sigma_statnuest, vertex_size = 0, plotly = FALSE) +
  ggtitle("Standard deviation") +
  theme_minimal() +
  theme(text = element_text(family = "Palatino"))
# Create a plot of the practical correlation range
r <- graph$plot_function(X = est_range_statnuest, vertex_size = 0, plotly = FALSE) +
  ggtitle("Practical correlation range") +
  theme_minimal() +
  theme(text = element_text(family = "Palatino"))
sr <- s + r
print(sr)
```


Below we consider the parameters obtained for the non-stationary model with $\nu = est$.


```{r}
theta_nonstatnuest <- mean_and_mode_params_nonstatnuest[3:6,1]
nu_nonstatnuest <- mean_and_mode_params_nonstatnuest[7,1]
op_nonstatnuest <- rSPDE::spde.matern.operators(graph = graph,
                                                parameterization = "spde",
                                                B.tau = B.tau,
                                                B.kappa = B.kappa,
                                                theta = theta_nonstatnuest,
                                                alpha = 0.5 + nu_nonstatnuest)


# Precision matrix
Q_nonstatnuest <- precision(op_nonstatnuest)
est_sigma_nonstatnuest <- sqrt(diag(INLA::inla.qinv(Q_nonstatnuest))) 
est_range_nonstatnuest <- compute_pcr(op_nonstatnuest, cor_threshold)

est_tau_nonstatnuest <- exp(B.tau[,-1]%*%theta_nonstatnuest)
est_kappa_nonstatnuest <- exp(B.kappa[,-1]%*%theta_nonstatnuest)
```


```{r, fig.width = 9.22, fig.height = 7.05, fig.cap = captioner("Standard deviation, practical correlation range, the model for tau, and the model for kappa for the non-stationary model with $\\nu$ estimated.")}
# Create a plot of the standard deviation
s <- graph$plot_function(X = est_sigma_nonstatnuest, vertex_size = 0, plotly = FALSE) +
  ggtitle("Standard deviation") +
  theme_minimal() +
  theme(text = element_text(family = "Palatino"))
# Create a plot of the practical correlation range
r <- graph$plot_function(X = est_range_nonstatnuest, vertex_size = 0, plotly = FALSE) +
  ggtitle("Practical correlation range") +
  theme_minimal() +
  theme(text = element_text(family = "Palatino"))
u <- graph$plot_function(X = est_tau_nonstatnuest, vertex_size = 0, plotly = FALSE) +
  ggtitle("Model for tau") +
  theme_minimal() +
  theme(text = element_text(family = "Palatino"))
# Create a plot of the practical correlation range
k <- graph$plot_function(X = est_kappa_nonstatnuest, vertex_size = 0, plotly = FALSE) +
  ggtitle("Model for kappa") +
  theme_minimal() +
  theme(text = element_text(family = "Palatino"))
sruk <- (s + r) / (u + k)
print(sruk)
```


```{r}
list_pems_repl3 <- list(est_sigma_statnu0.5 = est_sigma_statnu0.5,
                        est_range_statnu0.5 = est_range_statnu0.5,
                        est_sigma_nonstatnu0.5 = est_sigma_nonstatnu0.5,
                        est_range_nonstatnu0.5 = est_range_nonstatnu0.5,
                        est_tau_nonstatnu0.5 = est_tau_nonstatnu0.5,
                        est_kappa_nonstatnu0.5 = est_kappa_nonstatnu0.5,
                        est_sigma_statnu1.5 = est_sigma_statnu1.5,
                        est_range_statnu1.5 = est_range_statnu1.5,
                        est_sigma_nonstatnu1.5 = est_sigma_nonstatnu1.5,
                        est_range_nonstatnu1.5 = est_range_nonstatnu1.5,
                        est_tau_nonstatnu1.5 = est_tau_nonstatnu1.5,
                        est_kappa_nonstatnu1.5 = est_kappa_nonstatnu1.5,
                        est_sigma_statnuest = est_sigma_statnuest,
                        est_range_statnuest = est_range_statnuest,
                        est_sigma_nonstatnuest = est_sigma_nonstatnuest,
                        est_range_nonstatnuest = est_range_nonstatnuest,
                        est_tau_nonstatnuest = est_tau_nonstatnuest,
                        est_kappa_nonstatnuest = est_kappa_nonstatnuest,
                        graph = graph)
# Save the results
save(list_pems_repl3, file = here("data_files/pems_repl3_results.RData"))
```

# References

```{r}
cite_packages(output = "paragraph", out.dir = ".")
```


