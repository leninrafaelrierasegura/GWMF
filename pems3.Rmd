---
title: "PeMS data 2"
date: "Created: 05-07-2024. Last modified: `r format(Sys.time(), '%d-%m-%Y.')`"
output:
  html_document:
    mathjax: "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    highlight: pygments
    theme: flatly
    code_folding: show # class.source = "fold-hide" to hide code and add a button to show it
    # df_print: paged
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: true
    number_sections: true
    fig_caption: true
always_allow_html: true
bibliography:
  - references.bib
  - grateful-refs.bib
header-includes:
  - \newcommand{\ar}{\mathbb{R}}
  - \newcommand{\llav}[1]{\left\{#1\right\}}
  - \newcommand{\pare}[1]{\left(#1\right)}
  - \newcommand{\Ncal}{\mathcal{N}}
  - \newcommand{\Vcal}{\mathcal{V}}
  - \newcommand{\Ecal}{\mathcal{E}}
---

```{r, eval = FALSE, echo = FALSE}
################################################################################
################################################################################
################################################################################
################################################################################
######### DO NOT FORGET TO CHANGE THE TITLE EVERY TIME YOU FIT A MODEL #########
################################################################################
################################################################################
################################################################################
################################################################################
```

```{r xaringanExtra-clipboard, echo = FALSE}
htmltools::tagList(
  xaringanExtra::use_clipboard(
    button_text = "<i class=\"fa-solid fa-clipboard\" style=\"color: #00008B\"></i>",
    success_text = "<i class=\"fa fa-check\" style=\"color: #90BE6D\"></i>",
    error_text = "<i class=\"fa fa-times-circle\" style=\"color: #F94144\"></i>"
  ),
  rmarkdown::html_dependency_font_awesome()
)
```


```{css, echo = FALSE}
body .main-container {
  max-width: 100% !important;
  width: 100% !important;
}
body {
  max-width: 100% !important;
}

body, td {
   font-size: 16px;
}
code.r{
  font-size: 14px;
}
pre {
  font-size: 14px
}
```


Go back to the [About page](about.html).

Let us set some global options for all code chunks in this document.


```{r}
knitr::opts_chunk$set(
  message = FALSE,    # Disable messages printed by R code chunks
  warning = FALSE,    # Disable warnings printed by R code chunks
  echo = TRUE,        # Show R code within code chunks in output
  include = TRUE,     # Include both R code and its results in output
  eval = TRUE,       # Evaluate R code chunks
  cache = FALSE,       # Enable caching of R code chunks for faster rendering
  fig.align = "center",
  #out.width = "100%",
  retina = 2,
  error = TRUE,
  collapse = FALSE
)
rm(list = ls())
set.seed(1982)
```

# Import libraries

```{r}
library(INLA)
library(inlabru)
library(rSPDE)
library(MetricGraph)

library(dplyr)
library(plotly)
library(scales)
library(patchwork)
library(tidyr)
library(sf)

library(here)
library(rmarkdown)
library(grateful) # Cite all loaded packages

rm(list = ls()) # Clear the workspace
set.seed(1982) # Set seed for reproducibility
```

# Preprocessing

## Load the data

The data was downloaded from this [GitHub repository](https://github.com/davidbolin/MetricGraph/tree/7f4c90171c40b9bf7ea29e9b048c93d88477c5d1/examples/data.pems).

```{r}
Lines <- read_sf(here("data_files/data.pems/lines.shp"))
lines <- as_Spatial(Lines)

EtV <- read.csv(here("data_files/data.pems/E.csv"), header = T, row.names = NULL)
PtE <- read.csv(here("data_files/data.pems/PtE.csv"), header = T, row.names = NULL)
PtE[,1] <- PtE[,1] + 1
Y <- read.csv(here("data_files/data.pems/Y.csv"), header = T, row.names = NULL)
Y <- as.matrix(Y[,-1])
edge_length_m <- EtV[,4]
PtE[,2] = PtE[,2]/edge_length_m[PtE[,1]]
```

Matrix `Y` has dimension `r dim(Y)`. Each row of `Y` corresponds to a replicate (`r dim(Y)[1]` replicates in total) and each column corresponds to a location (`r dim(Y)[2]` locations in total) on the network.


```{r}
plot(lines)
PtE |> head(5) |> paged_table()
PtE |> dim()
Y |> as.data.frame() |> head(5) |> paged_table()
Y |> dim()
```


## Remove constant columns

We keep columns in `Y` that are not constant. We also keep only the corresponding rows in `PtE`.

```{r}
all_same <- function(col) {
  length(unique(col)) == 1
}
cols_to_keep <- apply(Y, 2, function(col) !all_same(col))

Y <- Y[, cols_to_keep]
PtE <- PtE[cols_to_keep,]
PtE |> dim()
Y |> dim()
```


## Partition the data

Half of the replicates (`Y_for_summary`) are used to compute the summary statistic (`Y_statistic`) and the other half (`Y` again ) are used to fit the model.

```{r}
sampled_numbers <- sample(1:26, 13, replace = FALSE)
not_sampled_numbers <- setdiff(1:26, sampled_numbers)
Y_for_summary <- Y[sampled_numbers,]
Y_statistic <- apply(Y_for_summary, 2, sd) |> as.vector() |> log()
Y_mean <- apply(Y_for_summary, 2, mean) |> as.vector()
Y <- Y[not_sampled_numbers,]
Y |> dim()
```

Observe that `Y_statistic` corresponds to $\log$ of the standard deviation at each location.

## Biuld the graph

```{r}
pems <- list(lines = lines, PtE = PtE, Y = Y)
graph <-  metric_graph$new(lines = pems$lines, longlat = TRUE)
graph$add_observations(data = data.frame(y = Y_statistic, edge_number = PtE[,1], distance_on_edge = pems$PtE[,2]), normalized = TRUE, clear_obs = TRUE)
graph$build_mesh(h = 0.05) # Build the mesh
graph$plot(data = "y", vertex_size = 0) + 
  ggtitle("Summary statistic using half of the replicates") + 
  theme_minimal() + 
  theme(text = element_text(family = "Palatino"))
```

## Covariate for the non-stationary model

Below we fit $\log(\mathrm{sd}(s_i))\sim N(\beta_0+u(s_i), \sigma_e^2)$.


```{r}
rspde_model_stat <- rspde.metric_graph(graph,
                                       parameterization = "matern")


data_rspde_bru_stat <- graph_data_rspde(rspde_model_stat,
                                        loc_name = "loc")

cmp_stat <- y ~ -1 +
  Intercept(1) +
  field(loc, model = rspde_model_stat)

rspde_fit_stat <-
  bru(cmp_stat,
      data = data_rspde_bru_stat[["data"]],
      family = "gaussian",
      options = list(verbose = FALSE)
  )

summary(rspde_fit_stat)
fit.rspde <- rspde.result(rspde_fit_stat, "field", rspde_model_stat)
summary(fit.rspde)
```

We now compute the kriging predictor $E(u(s_i)|\log(\mathrm{sd}(s_i)))$ (denoted as `cov` below) and standardize it.

```{r}
data_prd_list_mesh <- graph$get_mesh_locations(bru = TRUE, loc = "loc")
y_pred <- predict(rspde_model_stat, cmp_stat, rspde_fit_stat, newdata = data_prd_list_mesh, ~Intercept + field)
cov <- y_pred$pred$mean
cov <- (cov - mean(cov))/sd(cov)
# Plot the field
graph$plot_function(X = cov, vertex_size = 0) + 
  ggtitle("Standardized kriging predictor") + 
  theme_minimal() + 
  theme(text = element_text(family = "Palatino"))
```

We use `cov` to build the auxiliary matrices for the non-stationary models.

```{r}
# Non-stationary parameters
B.tau = cbind(0, 1, 0, cov, 0)
B.kappa = cbind(0, 0, 1, 0, cov)
```

## Covariate for the mean

```{r}
graph$add_observations(data = data.frame(y = Y_mean, edge_number = PtE[,1], distance_on_edge = pems$PtE[,2]), normalized = TRUE, clear_obs = TRUE)
graph$plot(data = "y", vertex_size = 0) + 
  ggtitle("Mean value using half of the replicates") + 
  theme_minimal() + 
  theme(text = element_text(family = "Palatino"))
# fit
rspde_model_stat <- rspde.metric_graph(graph,
                                       parameterization = "matern")


data_rspde_bru_stat <- graph_data_rspde(rspde_model_stat,
                                        loc_name = "loc")

cmp_stat <- y ~ -1 +
  Intercept(1) +
  field(loc, model = rspde_model_stat)

rspde_fit_stat <-
  bru(cmp_stat,
      data = data_rspde_bru_stat[["data"]],
      family = "gaussian",
      options = list(verbose = FALSE)
  )

summary(rspde_fit_stat)
fit.rspde <- rspde.result(rspde_fit_stat, "field", rspde_model_stat)
summary(fit.rspde)

data_aux <- data.frame(.edge_number = PtE[,1], .distance_on_edge = pems$PtE[,2])
data_prd_list <- list()
AAA = as.matrix(data.frame(data_aux$.edge_number, data_aux$.distance_on_edge))
colnames(AAA) = c("", "d.e")
data_prd_list[["loc"]] = rbind(AAA, data_prd_list_mesh$loc)

mean_y_pred <- predict(rspde_model_stat, cmp_stat, rspde_fit_stat, newdata = data_prd_list, ~Intercept + field)
mean_y_pred_aux <- mean_y_pred$pred$mean

cov_for_mean <- mean_y_pred_aux[1:nrow(AAA)]
cov_for_mean_to_plot <- mean_y_pred_aux[(nrow(AAA) + 1):length(mean_y_pred_aux)]

# Plot the field
graph$plot_function(X = cov_for_mean_to_plot, vertex_size = 0) + 
  ggtitle("Kriging predictor of the mean") + 
  theme_minimal() + 
  theme(text = element_text(family = "Palatino"))

```

```{r, fig.dim = c(20,5)}
plot(Y_mean, type = "l", col = "blue")
lines(cov_for_mean, col = "red")

sum(abs(Y_mean - cov_for_mean))
```

## Add the remaining replicates to the graph

We add the remaining half of the replicates to the graph.

```{r}
df_rep <- lapply(1:nrow(Y), function(i){data.frame(y = Y[i,],
                                                   mean_value = cov_for_mean,
                                                   edge_number = PtE[,1],
                                                   distance_on_edge = pems$PtE[,2],
                                                   repl = i)})
df_rep <- do.call(rbind, df_rep)

graph$add_observations(data = df_rep, normalized = TRUE, clear_obs = TRUE, group = "repl")

data <- graph$get_data()

graph$plot(data = "y", group = 1, vertex_size = 0) + 
  ggtitle("PeMS data, replicate 1") + 
  theme_minimal() + 
  theme(text = element_text(family = "Palatino"))
```

## Compute groups for cross-validation


```{r}
# Define aux data frame to compute the distance matrix
aux <- data |> filter(repl == 1) |>
  rename(distance_on_edge = .distance_on_edge, edge_number = .edge_number) |> # Rename the variables (because graph$compute_geodist_PtE() requires so)
  as.data.frame() |> # Transform to a data frame (i.e., remove the metric_graph class)
  dplyr::select(edge_number, distance_on_edge)

# Compute the distance matrix
distmatrix <- graph$compute_geodist_PtE(PtE = aux,
                                             normalized = TRUE,
                                             include_vertices = FALSE)
# Define the distance vector
distance = seq(from = 0, to = 10, by = 0.1)

GROUPS <- list()
for (j in 1:length(distance)) {
  GROUPS[[j]] = list()
  for (i in 1:nrow(aux)) {
    GROUPS[[j]][[i]] <- which(as.vector(distmatrix[i, ]) <= distance[j])
  }
}

NEW_GROUPS <- list()
for (j in 1:length(distance)) {
  my_list <- GROUPS[[j]]
  aux_list <- list()
  for (i in 0:(nrow(Y) - 1)) {
  added_vectors <- lapply(my_list, function(vec) vec + i*ncol(Y))
  aux_list <- c(aux_list, added_vectors)
  }
  NEW_GROUPS[[j]] <- aux_list
}

GROUPS <- NEW_GROUPS
```

## Check the groups

```{r}
indexofinterest <- 326 # Any number between 1 and nrow(data)
pointofinterest <- GROUPS[[20]][[indexofinterest]]
pointofinterest2 <- GROUPS[[50]][[indexofinterest]]
p <- graph$plot(vertex_size = 0) +
  geom_point(data = data, aes(x = .coord_x, y = .coord_y), color = "darkviolet") +
  geom_point(data = data[pointofinterest2, ], aes(x = .coord_x, y = .coord_y), color = "green") +
  geom_point(data = data[pointofinterest, ], aes(x = .coord_x, y = .coord_y), color = "blue") +
  geom_point(data = data[indexofinterest, ], aes(x = .coord_x, y = .coord_y), color = "red") +
  ggtitle("Groups") + 
  theme_minimal() + 
  theme(text = element_text(family = "Palatino")) +
  coord_fixed()
ggplotly(p)
```

## Auxiliary function

```{r}
cor_threshold <- 0.1 # Define correlation threshold

compute_pcr <- function(op, cor_threshold) {
  
  cov_matrix <- op$covariance_mesh()
  cor_matrix <-cov2cor(cov_matrix)
  op$graph$compute_geodist_mesh()
  dist_matrix <- op$graph$mesh$geo_dist
  pcr <- numeric(dim(cor_matrix)[1])
  
  process_row <- function(row_index) {
    df <- cbind(cor_matrix[row_index, ], dist_matrix[row_index, ])
    ordered_df <- df[order(df[, 2]), ]
    filtered_df <- ordered_df[ordered_df[,1] < cor_threshold, ]
    if (nrow(filtered_df) > 0) {
    return(filtered_df[1, 2])
      } else {
        min <- min(df[, 1])
    stop(paste0("The condition cor_matrix[row_index, ] < cor_threshold is not satisfied for row_index = ", row_index, ". Increase cor_threshold. The minimum value of cor_matrix[row_index, ] is ", min))
  }
  }
  
  pcr <- sapply(1:dim(cor_matrix)[1], process_row)
  
  return(pcr)
}
```


# Modeling

## $\nu = 0.5$

### Stationary model

```{r}
rspde_model_stat <- rspde.metric_graph(graph,
                                       parameterization = "spde",
                                       nu = 0.5)

data_rspde_bru_stat <- graph_data_rspde(rspde_model_stat,
                                        repl = ".all",
                                        loc_name = "loc")
cmp_stat <- y ~ -1 +
  Intercept(1) +
  mean_value +
  field(loc, model = rspde_model_stat,
        replicate = data_rspde_bru_stat[["repl"]])

rspde_fit_stat <-
  bru(cmp_stat,
      data = data_rspde_bru_stat[["data"]],
      family = "gaussian",
      options = list(verbose = FALSE)
  )
summary(rspde_fit_stat)
fit.rspde <- rspde.result(rspde_fit_stat, "field", rspde_model_stat)
summary(fit.rspde)

rspde_fit_statnu0.5 <- rspde_fit_stat
```

### Compute sd and range

```{r}
tau <- as.vector(fit.rspde[["summary.tau"]])$mean
kappa <- as.vector(fit.rspde[["summary.kappa"]])$mean
op_nu0.5stat <- rSPDE::matern.operators(graph = graph,
                                            parameterization = "spde",
                                            tau = tau,
                                            kappa = kappa,
                                            alpha = 1)


# Precision matrix
Q0.5stat <- precision(op_nu0.5stat)
est_sigma0.5stat <- sqrt(diag(INLA::inla.qinv(Q0.5stat))) 
est_range0.5stat <- compute_pcr(op_nu0.5stat, cor_threshold)
```

### Plot sd and range

```{r, fig.dim = c(9,4), class.source = "fold-hide"}
# Extract the mesh locations in Euclidean coordinates
xypoints <- graph$mesh$V

# Define data frames for plotting
est_df1 <- data.frame(x = xypoints[,1], y = xypoints[,2], z = est_sigma0.5stat, .group = 1)
est_df2 <- data.frame(x = xypoints[,1], y = xypoints[,2], z = est_range0.5stat, .group = 2)
data_param_cov <- rbind(est_df1, est_df2)

group_labels <- c("Marginal standard deviation", "Practical correlation range")

min_x <- min(data_param_cov$x) |> round(2)
max_x <- max(data_param_cov$x) |> round(2)
min_y <- min(data_param_cov$y) |> round(2)
max_y <- max(data_param_cov$y) |> round(2)

# Create a base plot
base_plot <- ggplot() +
  geom_point(data = est_df1, aes(x = x, y = y), color = "black", size = 0.1, shape = 1) +
  scale_x_continuous(labels = function(x) paste0(x), name = "Longitude") +  
  scale_y_continuous(labels = function(y) paste0(y), name = "Latitude") +
  theme_minimal() + 
  theme(text = element_text(family = "Palatino"))

# Create individual plots for each group and overlay data points
group_plots <- lapply(unique(data_param_cov$.group), function(gr) {
  geom_point(data = subset(data_param_cov, .group == gr), aes(x = x, y = y, color = z), size = 0.1)
})

# Combine the base plot and the group plots
combined_plot <- base_plot + 
  facet_wrap(~ .group, ncol = 2, labeller = labeller(.group = function(variable, value) {
    return(group_labels[value])
  })) +  # Specify custom labels for facet_wrap
  group_plots +
  scale_color_gradient(name = "") +
  labs(color = "") +
  scale_color_viridis_c(option = "D") + 
  theme(panel.spacing = unit(0.9, "cm"))

# Print the combined plot
print(combined_plot)
```

### Non-stationary model


```{r}
rspde_model_nonstat <- rspde.metric_graph(graph,
                                          B.tau = B.tau,
                                          B.kappa =  B.kappa,
                                          parameterization = "spde",
                                          nu = 0.5)

data_rspde_bru_nonstat <- graph_data_rspde(rspde_model_nonstat,
                                           repl = ".all",
                                           loc_name = "loc")
cmp_nonstat <- y ~ -1 +
  Intercept(1) +
  mean_value +
  field(loc, model = rspde_model_nonstat,
        replicate = data_rspde_bru_nonstat[["repl"]])

rspde_fit_nonstat <-
  bru(cmp_nonstat,
      data = data_rspde_bru_nonstat[["data"]],
      family = "gaussian",
      options = list(verbose = FALSE)
  )

summary(rspde_fit_nonstat)
summary(rspde.result(rspde_fit_nonstat, "field", rspde_model_nonstat))


rspde_fit_nonstatnu0.5 <- rspde_fit_nonstat
```


### Compute sd and range

```{r}
theta <- rspde_fit_nonstat[["summary.hyperpar"]][["mean"]][2:5]
ns_op_nu0.5 <- rSPDE::spde.matern.operators(graph = graph,
                                            parameterization = "spde",
                                            B.tau = B.tau,
                                            B.kappa = B.kappa,
                                            theta = theta,
                                            alpha = 1)


# Precision matrix
Q0.5 <- precision(ns_op_nu0.5)
est_sigma0.5 <- sqrt(diag(INLA::inla.qinv(Q0.5))) 
est_range0.5 <- compute_pcr(ns_op_nu0.5, cor_threshold)

est_kappa0.5 <- exp(B.kappa[,-1]%*%theta)
est_tau0.5 <- exp(B.tau[,-1]%*%theta)
```

### Plot sd and range

```{r, fig.dim = c(9,4), class.source = "fold-hide"}
# Extract the mesh locations in Euclidean coordinates
xypoints <- graph$mesh$V

# Define data frames for plotting
est_df1 <- data.frame(x = xypoints[,1], y = xypoints[,2], z = est_sigma0.5, .group = 1)
est_df2 <- data.frame(x = xypoints[,1], y = xypoints[,2], z = est_range0.5, .group = 2)
data_param_cov <- rbind(est_df1, est_df2)

group_labels <- c("Marginal standard deviation", "Practical correlation range")

min_x <- min(data_param_cov$x) |> round(2)
max_x <- max(data_param_cov$x) |> round(2)
min_y <- min(data_param_cov$y) |> round(2)
max_y <- max(data_param_cov$y) |> round(2)

# Create a base plot
base_plot <- ggplot() +
  geom_point(data = est_df1, aes(x = x, y = y), color = "black", size = 0.1, shape = 1) +
  scale_x_continuous(labels = function(x) paste0(x), name = "Longitude") +  
  scale_y_continuous(labels = function(y) paste0(y), name = "Latitude") +
  theme_minimal() + 
  theme(text = element_text(family = "Palatino"))

# Create individual plots for each group and overlay data points
group_plots <- lapply(unique(data_param_cov$.group), function(gr) {
  geom_point(data = subset(data_param_cov, .group == gr), aes(x = x, y = y, color = z), size = 0.1)
})

# Combine the base plot and the group plots
combined_plot <- base_plot + 
  facet_wrap(~ .group, ncol = 2, labeller = labeller(.group = function(variable, value) {
    return(group_labels[value])
  })) +  # Specify custom labels for facet_wrap
  group_plots +
  scale_color_gradient(name = "") +
  labs(color = "") +
  scale_color_viridis_c(option = "D") + 
  theme(panel.spacing = unit(0.9, "cm"))

# Print the combined plot
print(combined_plot)
```


### Plot $\tau$ and $\kappa$

```{r, fig.dim = c(9,4), class.source = "fold-hide"}
# Extract the mesh locations in Euclidean coordinates
xypoints <- graph$mesh$V

# Define data frames for plotting
est_df1 <- data.frame(x = xypoints[,1], y = xypoints[,2], z = est_tau0.5, .group = 1)
est_df2 <- data.frame(x = xypoints[,1], y = xypoints[,2], z = est_kappa0.5, .group = 2)
data_param_cov <- rbind(est_df1, est_df2)

group_labels <- c("Tau", "Kappa")

min_x <- min(data_param_cov$x) |> round(2)
max_x <- max(data_param_cov$x) |> round(2)
min_y <- min(data_param_cov$y) |> round(2)
max_y <- max(data_param_cov$y) |> round(2)

# Create a base plot
base_plot <- ggplot() +
  geom_point(data = est_df1, aes(x = x, y = y), color = "black", size = 0.1, shape = 1) +
  scale_x_continuous(labels = function(x) paste0(x), name = "Longitude") +  
  scale_y_continuous(labels = function(y) paste0(y), name = "Latitude") +
  theme_minimal() + 
  theme(text = element_text(family = "Palatino"))

# Create individual plots for each group and overlay data points
group_plots <- lapply(unique(data_param_cov$.group), function(gr) {
  geom_point(data = subset(data_param_cov, .group == gr), aes(x = x, y = y, color = z), size = 0.1)
})

# Combine the base plot and the group plots
combined_plot <- base_plot + 
  facet_wrap(~ .group, ncol = 2, labeller = labeller(.group = function(variable, value) {
    return(group_labels[value])
  })) +  # Specify custom labels for facet_wrap
  group_plots +
  scale_color_gradient(name = "") +
  labs(color = "") +
  scale_color_viridis_c(option = "D") + 
  theme(panel.spacing = unit(0.9, "cm"))

# Print the combined plot
print(combined_plot)
```

## $\nu = 1.5$

### Stationary model

```{r}
rspde_model_stat <- rspde.metric_graph(graph,
                                       parameterization = "spde",
                                       nu = 1.5)

data_rspde_bru_stat <- graph_data_rspde(rspde_model_stat,
                                        repl = ".all",
                                        loc_name = "loc")

cmp_stat <- y ~ -1 +
  Intercept(1) +
  mean_value +
  field(loc, model = rspde_model_stat,
        replicate = data_rspde_bru_stat[["repl"]])

rspde_fit_stat <-
  bru(cmp_stat,
      data = data_rspde_bru_stat[["data"]],
      family = "gaussian",
      options = list(verbose = FALSE)
  )

summary(rspde_fit_stat)
fit.rspde <- rspde.result(rspde_fit_stat, "field", rspde_model_stat)
summary(fit.rspde)

rspde_fit_statnu1.5 <- rspde_fit_stat
```

### Compute sd and range

```{r}
tau <- as.vector(fit.rspde[["summary.tau"]])$mean
kappa <- as.vector(fit.rspde[["summary.kappa"]])$mean
op_nu1.5stat <- rSPDE::matern.operators(graph = graph,
                                            parameterization = "spde",
                                            tau = tau,
                                            kappa = kappa,
                                            alpha = 2)


# Precision matrix
Q1.5stat <- precision(op_nu1.5stat)
est_sigma1.5stat <- sqrt(diag(INLA::inla.qinv(Q1.5stat))) 
est_range1.5stat <- compute_pcr(op_nu1.5stat, cor_threshold)
```

### Plot sd and range

```{r, fig.dim = c(9,4), class.source = "fold-hide"}
# Extract the mesh locations in Euclidean coordinates
xypoints <- graph$mesh$V

# Define data frames for plotting
est_df1 <- data.frame(x = xypoints[,1], y = xypoints[,2], z = est_sigma1.5stat, .group = 1)
est_df2 <- data.frame(x = xypoints[,1], y = xypoints[,2], z = est_range1.5stat, .group = 2)
data_param_cov <- rbind(est_df1, est_df2)

group_labels <- c("Marginal standard deviation", "Practical correlation range")

min_x <- min(data_param_cov$x) |> round(2)
max_x <- max(data_param_cov$x) |> round(2)
min_y <- min(data_param_cov$y) |> round(2)
max_y <- max(data_param_cov$y) |> round(2)

# Create a base plot
base_plot <- ggplot() +
  geom_point(data = est_df1, aes(x = x, y = y), color = "black", size = 0.1, shape = 1) +
  scale_x_continuous(labels = function(x) paste0(x), name = "Longitude") +  
  scale_y_continuous(labels = function(y) paste0(y), name = "Latitude") +
  theme_minimal() + 
  theme(text = element_text(family = "Palatino"))

# Create individual plots for each group and overlay data points
group_plots <- lapply(unique(data_param_cov$.group), function(gr) {
  geom_point(data = subset(data_param_cov, .group == gr), aes(x = x, y = y, color = z), size = 0.1)
})

# Combine the base plot and the group plots
combined_plot <- base_plot + 
  facet_wrap(~ .group, ncol = 2, labeller = labeller(.group = function(variable, value) {
    return(group_labels[value])
  })) +  # Specify custom labels for facet_wrap
  group_plots +
  scale_color_gradient(name = "") +
  labs(color = "") +
  scale_color_viridis_c(option = "D") + 
  theme(panel.spacing = unit(0.9, "cm"))

# Print the combined plot
print(combined_plot)
```



### Non-stationary model

```{r}
rspde_model_nonstat <- rspde.metric_graph(graph,
                                          B.tau = B.tau,
                                          B.kappa =  B.kappa,
                                          parameterization = "spde",
                                          nu = 1.5)

data_rspde_bru_nonstat <- graph_data_rspde(rspde_model_nonstat,
                                           repl = ".all",
                                           loc_name = "loc")

cmp_nonstat <- y ~ -1 +
  Intercept(1) +
  mean_value +
  field(loc, model = rspde_model_nonstat,
        replicate = data_rspde_bru_nonstat[["repl"]])

rspde_fit_nonstat <-
  bru(cmp_nonstat,
      data = data_rspde_bru_nonstat[["data"]],
      family = "gaussian",
      options = list(verbose = FALSE)
  )

summary(rspde_fit_nonstat)
summary(rspde.result(rspde_fit_nonstat, "field", rspde_model_nonstat))


rspde_fit_nonstatnu1.5 <- rspde_fit_nonstat
```

### Compute sd and range

```{r}
theta <- rspde_fit_nonstat[["summary.hyperpar"]][["mean"]][2:5]
ns_op_nu1.5 <- rSPDE::spde.matern.operators(graph = graph,
                                            parameterization = "spde",
                                            B.tau = B.tau,
                                            B.kappa = B.kappa,
                                            theta = theta,
                                            alpha = 2)


# Precision matrix
Q1.5 <- precision(ns_op_nu1.5)
est_sigma1.5 <- sqrt(diag(INLA::inla.qinv(Q1.5))) 
est_range1.5 <- compute_pcr(ns_op_nu1.5, cor_threshold)

est_kappa1.5 <- exp(B.kappa[,-1]%*%theta)
est_tau1.5 <- exp(B.tau[,-1]%*%theta)
```

### Plot sd and range

```{r, fig.dim = c(9,4), class.source = "fold-hide"}
# Extract the mesh locations in Euclidean coordinates
xypoints <- graph$mesh$V

# Define data frames for plotting
est_df1 <- data.frame(x = xypoints[,1], y = xypoints[,2], z = est_sigma1.5, .group = 1)
est_df2 <- data.frame(x = xypoints[,1], y = xypoints[,2], z = est_range1.5, .group = 2)
data_param_cov <- rbind(est_df1, est_df2)

group_labels <- c("Marginal standard deviation", "Practical correlation range")

min_x <- min(data_param_cov$x) |> round(2)
max_x <- max(data_param_cov$x) |> round(2)
min_y <- min(data_param_cov$y) |> round(2)
max_y <- max(data_param_cov$y) |> round(2)

# Create a base plot
base_plot <- ggplot() +
  geom_point(data = est_df1, aes(x = x, y = y), color = "black", size = 0.1, shape = 1) +
  scale_x_continuous(labels = function(x) paste0(x), name = "Longitude") +  
  scale_y_continuous(labels = function(y) paste0(y), name = "Latitude") +
  theme_minimal() + 
  theme(text = element_text(family = "Palatino"))

# Create individual plots for each group and overlay data points
group_plots <- lapply(unique(data_param_cov$.group), function(gr) {
  geom_point(data = subset(data_param_cov, .group == gr), aes(x = x, y = y, color = z), size = 0.1)
})

# Combine the base plot and the group plots
combined_plot <- base_plot + 
  facet_wrap(~ .group, ncol = 2, labeller = labeller(.group = function(variable, value) {
    return(group_labels[value])
  })) +  # Specify custom labels for facet_wrap
  group_plots +
  scale_color_gradient(name = "") +
  labs(color = "") +
  scale_color_viridis_c(option = "D") + 
  theme(panel.spacing = unit(0.9, "cm"))

# Print the combined plot
print(combined_plot)
```

### Plot $\tau$ and $\kappa$

```{r, fig.dim = c(9,4), class.source = "fold-hide"}
# Extract the mesh locations in Euclidean coordinates
xypoints <- graph$mesh$V

# Define data frames for plotting
est_df1 <- data.frame(x = xypoints[,1], y = xypoints[,2], z = est_tau1.5, .group = 1)
est_df2 <- data.frame(x = xypoints[,1], y = xypoints[,2], z = est_kappa1.5, .group = 2)
data_param_cov <- rbind(est_df1, est_df2)

group_labels <- c("Tau", "Kappa")

min_x <- min(data_param_cov$x) |> round(2)
max_x <- max(data_param_cov$x) |> round(2)
min_y <- min(data_param_cov$y) |> round(2)
max_y <- max(data_param_cov$y) |> round(2)

# Create a base plot
base_plot <- ggplot() +
  geom_point(data = est_df1, aes(x = x, y = y), color = "black", size = 0.1, shape = 1) +
  scale_x_continuous(labels = function(x) paste0(x), name = "Longitude") +  
  scale_y_continuous(labels = function(y) paste0(y), name = "Latitude") +
  theme_minimal() + 
  theme(text = element_text(family = "Palatino"))

# Create individual plots for each group and overlay data points
group_plots <- lapply(unique(data_param_cov$.group), function(gr) {
  geom_point(data = subset(data_param_cov, .group == gr), aes(x = x, y = y, color = z), size = 0.1)
})

# Combine the base plot and the group plots
combined_plot <- base_plot + 
  facet_wrap(~ .group, ncol = 2, labeller = labeller(.group = function(variable, value) {
    return(group_labels[value])
  })) +  # Specify custom labels for facet_wrap
  group_plots +
  scale_color_gradient(name = "") +
  labs(color = "") +
  scale_color_viridis_c(option = "D") + 
  theme(panel.spacing = unit(0.9, "cm"))

# Print the combined plot
print(combined_plot)
```

## $\nu$ estimated

### Stationary model

```{r}
rspde_model_stat <- rspde.metric_graph(graph,
                                       parameterization = "spde")


data_rspde_bru_stat <- graph_data_rspde(rspde_model_stat,
                                        repl = ".all",
                                        loc_name = "loc")

cmp_stat <- y ~ -1 +
  Intercept(1) +
  mean_value +
  field(loc, model = rspde_model_stat,
        replicate = data_rspde_bru_stat[["repl"]])

rspde_fit_stat <-
  bru(cmp_stat,
      data = data_rspde_bru_stat[["data"]],
      family = "gaussian",
      options = list(verbose = FALSE)
  )

summary(rspde_fit_stat)
fit.rspde <- rspde.result(rspde_fit_stat, "field", rspde_model_stat)
summary(fit.rspde)

rspde_fit_statnuest <- rspde_fit_stat
```

### Compute sd and range

```{r}
tau <- as.vector(fit.rspde[["summary.tau"]])$mean
kappa <- as.vector(fit.rspde[["summary.kappa"]])$mean
nu_l <- as.vector(fit.rspde[["summary.nu"]])$mean
op_nueststat <- rSPDE::matern.operators(graph = graph,
                                            parameterization = "spde",
                                            tau = tau,
                                            kappa = kappa,
                                            alpha = nu_l + 0.5)


# Precision matrix
Qeststat <- precision(op_nueststat)
est_sigmaeststat <- sqrt(diag(INLA::inla.qinv(Qeststat))) 
est_rangeeststat <- compute_pcr(op_nueststat, cor_threshold)
```

### Plot sd and range

```{r, fig.dim = c(9,4), class.source = "fold-hide"}
# Extract the mesh locations in Euclidean coordinates
xypoints <- graph$mesh$V

# Define data frames for plotting
est_df1 <- data.frame(x = xypoints[,1], y = xypoints[,2], z = est_sigmaeststat, .group = 1)
est_df2 <- data.frame(x = xypoints[,1], y = xypoints[,2], z = est_rangeeststat, .group = 2)
data_param_cov <- rbind(est_df1, est_df2)

group_labels <- c("Marginal standard deviation", "Practical correlation range")

min_x <- min(data_param_cov$x) |> round(2)
max_x <- max(data_param_cov$x) |> round(2)
min_y <- min(data_param_cov$y) |> round(2)
max_y <- max(data_param_cov$y) |> round(2)

# Create a base plot
base_plot <- ggplot() +
  geom_point(data = est_df1, aes(x = x, y = y), color = "black", size = 0.1, shape = 1) +
  scale_x_continuous(labels = function(x) paste0(x), name = "Longitude") +  
  scale_y_continuous(labels = function(y) paste0(y), name = "Latitude") +
  theme_minimal() + 
  theme(text = element_text(family = "Palatino"))

# Create individual plots for each group and overlay data points
group_plots <- lapply(unique(data_param_cov$.group), function(gr) {
  geom_point(data = subset(data_param_cov, .group == gr), aes(x = x, y = y, color = z), size = 0.1)
})

# Combine the base plot and the group plots
combined_plot <- base_plot + 
  facet_wrap(~ .group, ncol = 2, labeller = labeller(.group = function(variable, value) {
    return(group_labels[value])
  })) +  # Specify custom labels for facet_wrap
  group_plots +
  scale_color_gradient(name = "") +
  labs(color = "") +
  scale_color_viridis_c(option = "D") + 
  theme(panel.spacing = unit(0.9, "cm"))

# Print the combined plot
print(combined_plot)
```


### Non-stationary model

```{r}
rspde_model_nonstat <- rspde.metric_graph(graph,
                                          B.tau = B.tau,
                                          B.kappa =  B.kappa,
                                          parameterization = "spde")

data_rspde_bru_nonstat <- graph_data_rspde(rspde_model_nonstat,
                                           repl = ".all",
                                           loc_name = "loc")

cmp_nonstat <- y ~ -1 +
  Intercept(1) +
  mean_value +
  field(loc, model = rspde_model_nonstat,
        replicate = data_rspde_bru_nonstat[["repl"]])

rspde_fit_nonstat <-
  bru(cmp_nonstat,
      data = data_rspde_bru_nonstat[["data"]],
      family = "gaussian",
      options = list(verbose = FALSE)
  )

summary(rspde_fit_nonstat)
LL <- rspde.result(rspde_fit_nonstat, "field", rspde_model_nonstat)
summary(LL)
# rspde_fit_nonstat <-bru_rerun(rspde_fit_nonstat)
# summary(rspde_fit_nonstat)
# summary(rspde.result(rspde_fit_nonstat, "field", rspde_model_nonstat))

rspde_fit_nonstatnuest <- rspde_fit_nonstat
```

### Compute sd and range

```{r}
theta <- rspde_fit_nonstat[["summary.hyperpar"]][["mean"]][2:5]
nu_estt <- as.vector(LL[["summary.nu"]])$mean
ns_op_nuest <- rSPDE::spde.matern.operators(graph = graph,
                                            parameterization = "spde",
                                            B.tau = B.tau,
                                            B.kappa = B.kappa,
                                            theta = theta,
                                            alpha = nu_estt + 0.5)


# Precision matrix
Qest <- precision(ns_op_nuest)
est_sigmaest <- sqrt(diag(INLA::inla.qinv(Qest))) 
est_rangeest <- compute_pcr(ns_op_nuest, cor_threshold)

est_kappaest <- exp(B.kappa[,-1]%*%theta)
est_tauest <- exp(B.tau[,-1]%*%theta)
```


### Plot sd and range


```{r, fig.dim = c(9,4), class.source = "fold-hide"}
# Extract the mesh locations in Euclidean coordinates
xypoints <- graph$mesh$V

# Define data frames for plotting
est_df1 <- data.frame(x = xypoints[,1], y = xypoints[,2], z = est_sigmaest, .group = 1)
est_df2 <- data.frame(x = xypoints[,1], y = xypoints[,2], z = est_rangeest, .group = 2)
data_param_cov <- rbind(est_df1, est_df2)

group_labels <- c("Marginal standard deviation", "Practical correlation range")

min_x <- min(data_param_cov$x) |> round(2)
max_x <- max(data_param_cov$x) |> round(2)
min_y <- min(data_param_cov$y) |> round(2)
max_y <- max(data_param_cov$y) |> round(2)

# Create a base plot
base_plot <- ggplot() +
  geom_point(data = est_df1, aes(x = x, y = y), color = "black", size = 0.1, shape = 1) +
  scale_x_continuous(labels = function(x) paste0(x), name = "Longitude") +  
  scale_y_continuous(labels = function(y) paste0(y), name = "Latitude") +
  theme_minimal() + 
  theme(text = element_text(family = "Palatino"))

# Create individual plots for each group and overlay data points
group_plots <- lapply(unique(data_param_cov$.group), function(gr) {
  geom_point(data = subset(data_param_cov, .group == gr), aes(x = x, y = y, color = z), size = 0.1)
})

# Combine the base plot and the group plots
combined_plot <- base_plot + 
  facet_wrap(~ .group, ncol = 2, labeller = labeller(.group = function(variable, value) {
    return(group_labels[value])
  })) +  # Specify custom labels for facet_wrap
  group_plots +
  scale_color_gradient(name = "") +
  labs(color = "") +
  scale_color_viridis_c(option = "D") + 
  theme(panel.spacing = unit(0.9, "cm"))

# Print the combined plot
print(combined_plot)
```

### Plot $\tau$ and $\kappa$

```{r, fig.dim = c(9,4), class.source = "fold-hide"}
# Extract the mesh locations in Euclidean coordinates
xypoints <- graph$mesh$V

# Define data frames for plotting
est_df1 <- data.frame(x = xypoints[,1], y = xypoints[,2], z = est_tauest, .group = 1)
est_df2 <- data.frame(x = xypoints[,1], y = xypoints[,2], z = est_kappaest, .group = 2)
data_param_cov <- rbind(est_df1, est_df2)

group_labels <- c("Tau", "Kappa")

min_x <- min(data_param_cov$x) |> round(2)
max_x <- max(data_param_cov$x) |> round(2)
min_y <- min(data_param_cov$y) |> round(2)
max_y <- max(data_param_cov$y) |> round(2)

# Create a base plot
base_plot <- ggplot() +
  geom_point(data = est_df1, aes(x = x, y = y), color = "black", size = 0.1, shape = 1) +
  scale_x_continuous(labels = function(x) paste0(x), name = "Longitude") +  
  scale_y_continuous(labels = function(y) paste0(y), name = "Latitude") +
  theme_minimal() + 
  theme(text = element_text(family = "Palatino"))

# Create individual plots for each group and overlay data points
group_plots <- lapply(unique(data_param_cov$.group), function(gr) {
  geom_point(data = subset(data_param_cov, .group == gr), aes(x = x, y = y, color = z), size = 0.1)
})

# Combine the base plot and the group plots
combined_plot <- base_plot + 
  facet_wrap(~ .group, ncol = 2, labeller = labeller(.group = function(variable, value) {
    return(group_labels[value])
  })) +  # Specify custom labels for facet_wrap
  group_plots +
  scale_color_gradient(name = "") +
  labs(color = "") +
  scale_color_viridis_c(option = "D") + 
  theme(panel.spacing = unit(0.9, "cm"))

# Print the combined plot
print(combined_plot)
```

# Cross-validation


```{r}
mse.statnu0.5 <- mse.nonstatnu0.5 <- ls.statnu0.5 <- ls.nonstatnu0.5 <- rep(0,length(distance))
mse.statnu1.5 <- mse.nonstatnu1.5 <- ls.statnu1.5 <- ls.nonstatnu1.5 <- rep(0,length(distance))
mse.statnuest <- mse.nonstatnuest <- ls.statnuest <- ls.nonstatnuest <- rep(0,length(distance))

# cross-validation for-loop
for (j in 1:length(distance)) {
  print(j)
  # cross-validation of the stationary model
  cv.statnu0.5 <- inla.group.cv(rspde_fit_statnu0.5, groups = GROUPS[[j]])
  cv.statnu1.5 <- inla.group.cv(rspde_fit_statnu1.5, groups = GROUPS[[j]])
  cv.statnuest <- inla.group.cv(rspde_fit_statnuest, groups = GROUPS[[j]])
  # cross-validation of the nonstationary model
  cv.nonstatnu0.5 <- inla.group.cv(rspde_fit_nonstatnu0.5, groups = GROUPS[[j]])
  cv.nonstatnu1.5 <- inla.group.cv(rspde_fit_nonstatnu1.5, groups = GROUPS[[j]])
  cv.nonstatnuest <- inla.group.cv(rspde_fit_nonstatnuest, groups = GROUPS[[j]])
  # obtain MSE and LS
  mse.statnu0.5[j] <- mean((cv.statnu0.5$mean - data$y)^2)
  mse.statnu1.5[j] <- mean((cv.statnu1.5$mean - data$y)^2)
  mse.statnuest[j] <- mean((cv.statnuest$mean - data$y)^2)
  
  
  mse.nonstatnu0.5[j] <- mean((cv.nonstatnu0.5$mean - data$y)^2)
  mse.nonstatnu1.5[j] <- mean((cv.nonstatnu1.5$mean - data$y)^2)
  mse.nonstatnuest[j] <- mean((cv.nonstatnuest$mean - data$y)^2)
  
  
  ls.statnu0.5[j] <- mean(log(cv.statnu0.5$cv))
  ls.statnu1.5[j] <- mean(log(cv.statnu1.5$cv))
  ls.statnuest[j] <- mean(log(cv.statnuest$cv))
  
  ls.nonstatnu0.5[j] <- mean(log(cv.nonstatnu0.5$cv))
  ls.nonstatnu1.5[j] <- mean(log(cv.nonstatnu1.5$cv))
  ls.nonstatnuest[j] <- mean(log(cv.nonstatnuest$cv))
}

# Create data frames
mse_df <- data.frame(
  distance,
  Statnu0.5 = mse.statnu0.5,
  Nonstatnu0.5 = mse.nonstatnu0.5,
  Statnu1.5 = mse.statnu1.5,
  Nonstatnu1.5 = mse.nonstatnu1.5,
  Statnuest = mse.statnuest,
  Nonstatnuest = mse.nonstatnuest
)

ls_df <- data.frame(
  distance,
  Statnu0.5 = -ls.statnu0.5,
  Nonstatnu0.5 = -ls.nonstatnu0.5,
  Statnu1.5 = -ls.statnu1.5,
  Nonstatnu1.5 = -ls.nonstatnu1.5,
  Statnuest = -ls.statnuest,
  Nonstatnuest = -ls.nonstatnuest
)
```

```{r, fig.dim = c(16,6), fig.cap = "MSE and negative Log-Score as functions of distance (in km) for the stationary (dotdash line, $\\boldsymbol{\\cdot-\\cdot}$) and non-stationary (solid line, $\\boldsymbol{-\\!\\!\\!-\\!\\!\\!-}$)  cases with $\\nu = 0.5$, $\\nu = 1.5$, and $\\nu$ estimated (est)."}

# Convert to long format
mse_long <- mse_df %>%
  pivot_longer(cols = -distance, names_to = "nu", values_to = "MSE")

ls_long <- ls_df %>%
  pivot_longer(cols = -distance, names_to = "nu", values_to = "LogScore")


# Update the label mappings with the new legend title
label_mapping <- c(
  "Statnu0.5" = "0.5", 
  "Nonstatnu0.5" = "0.5", 
  "Statnu1.5" = "1.5", 
  "Nonstatnu1.5" = "1.5", 
  "Statnuest" = "est", 
  "Nonstatnuest" = "est"
)

# Define color and linetype mapping
color_mapping <- c(
  "Statnu0.5" = "blue", 
  "Nonstatnu0.5" = "red", 
  "Statnu1.5" = "black", 
  "Nonstatnu1.5" = "green", 
  "Statnuest" = "darkorange", 
  "Nonstatnuest" = "skyblue"
)

linetype_mapping <- c(
  "Statnu0.5" = "dotdash", 
  "Nonstatnu0.5" = "solid", 
  "Statnu1.5" = "dotdash", 
  "Nonstatnu1.5" = "solid", 
  "Statnuest" = "dotdash", 
  "Nonstatnuest" = "solid"
)

# Plot MSE
mse_plot <- ggplot(mse_long, aes(x = distance, y = MSE, color = nu, linetype = nu)) +
  geom_line(linewidth = 1) +
  labs(y = "MSE", x = "Distance in km") +
  scale_color_manual(values = color_mapping, labels = label_mapping, name = expression(nu)) +
  scale_linetype_manual(values = linetype_mapping, labels = label_mapping, name = expression(nu)) +
  theme_minimal() +
  theme(text = element_text(family = "Palatino"))

# Plot negative log-score
ls_plot <- ggplot(ls_long, aes(x = distance, y = LogScore, color = nu, linetype = nu)) +
  geom_line(linewidth = 1) +
  labs(y = "Negative Log-Score", x = "Distance in km") +
  scale_color_manual(values = color_mapping, labels = label_mapping, name = expression(nu)) +
  scale_linetype_manual(values = linetype_mapping, labels = label_mapping, name = expression(nu)) +
  theme_minimal() +
  theme(text = element_text(family = "Palatino"))

# Combine plots with a shared legend at the top in a single line
combined_plot <- mse_plot + ls_plot + 
  plot_layout(guides = 'collect') & 
  theme(legend.position = 'right') & 
  guides(color = guide_legend(ncol = 1), linetype = guide_legend(nrow = 1))

# Display combined plot
print(combined_plot)
```

```{r}
save.image(here("data_files/pems3_all_data.RData"))
```

# References

```{r}
cite_packages(output = "paragraph", out.dir = ".")
```


